/*--------------------------------------------------------------------------------------------------------------------*/
#if defined(ARDUINO)
/*--------------------------------------------------------------------------------------------------------------------*/

#include <string>
#include <stdlib.h>

#ifndef ESP8266
#  include <WiFi.h>
#else
#  include <ESP8266WiFi.h>
#endif

#include <Arduino.h>
#include <PubSubClient.h>

#include "../nyx_node_internal.h"

/*--------------------------------------------------------------------------------------------------------------------*/

#define MAX_TCP_CLIENTS 10

#define RECV_BUFF_SIZE 512

/*--------------------------------------------------------------------------------------------------------------------*/

struct nyx_stack_s
{
    /*----------------------------------------------------------------------------------------------------------------*/

    WiFiServer tcp_server;

    /*----------------------------------------------------------------------------------------------------------------*/

    struct tcp_client_s
    {
        WiFiClient tcp_client;

        char recv_buff[RECV_BUFF_SIZE];

        size_t recv_head = 0;
        size_t recv_tail = 0;

    } clients[MAX_TCP_CLIENTS];

    /*----------------------------------------------------------------------------------------------------------------*/

    PubSubClient mqtt_client;

    __NULLABLE__ STR_t mqtt_username = NULL;
    __NULLABLE__ STR_t mqtt_password = NULL;

    /*----------------------------------------------------------------------------------------------------------------*/
};

/*--------------------------------------------------------------------------------------------------------------------*/
/* LOGGER                                                                                                             */
/*--------------------------------------------------------------------------------------------------------------------*/
/*
extern "C" int putchar(int c)
{
    Serial.write((char) c);

    return c;
}
*/
/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_log_prefix(nyx_log_level_t level, STR_t file, STR_t func, int line)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    STR_t p;

    p = strrchr(file, '/');

    if(p != NULL)
    {
        file = p + 1;
    }
    else
    {
        p = strrchr(file, '\\');

        if(p != NULL)
        {
            file = p + 1;
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    printf("%s - %s: %d %s() - ", nyx_log_level_to_str(level), file, line, func);

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_log(const char *fmt, ...)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    va_end(ap);

    /*----------------------------------------------------------------------------------------------------------------*/

    putchar('\r');
    putchar('\n');

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/
/* TCP & MQTT                                                                                                         */
/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_tcp_pub(nyx_node_t *node, STR_t message)
{
    auto clients = node->stack->clients;

    for(int i = 0; i < MAX_TCP_CLIENTS; i++)
    {
        WiFiClient tcp_client = clients[i].tcp_client;

        if(tcp_client && tcp_client.connected())
        {
            tcp_client.write(message, strlen(message));
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_mqtt_sub(nyx_node_t *node, nyx_str_t topic, int qos)
{
    if(node->mqtt_url != NULL && node->stack->mqtt_client.connected())
    {
        node->stack->mqtt_client.subscribe(topic.buf, qos);
    }
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_mqtt_pub(nyx_node_t *node, nyx_str_t topic, nyx_str_t message, int qos, bool retain)
{
    if(node->mqtt_url != NULL && node->stack->mqtt_client.connected())
    {
        node->stack->mqtt_client.publish(topic.buf, (const uint8_t *) message.buf, (unsigned int) message.len, retain);
    }
}

/*--------------------------------------------------------------------------------------------------------------------*/
/* STACK                                                                                                              */
/*--------------------------------------------------------------------------------------------------------------------*/

static bool parse_host_port(const std::string &url, IPAddress &ip, int &port, int default_port)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    std::string host;

    size_t colon = url.find(':');

    if(colon == std::string::npos)
    {
        host = url;
        port = default_port;
    }
    else
    {
        host = url.substr(0, colon);
        port = atoi(url.substr(colon + 1).c_str());
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(ip.fromString(host.c_str()))
    {
        return true;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(WiFi.hostByName(host.c_str(), ip) == 1)
    {
        return true;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    return false;
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_node_stack_initialize(
    nyx_node_t *node,
    __NULLABLE__ STR_t mqtt_username,
    __NULLABLE__ STR_t mqtt_password,
    int retry_ms
) {
    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_stack_t *stack = node->stack = (nyx_stack_t *) nyx_memory_alloc(sizeof(nyx_stack_t));

    /*----------------------------------------------------------------------------------------------------------------*/

    stack->mqtt_username = mqtt_username;
    stack->mqtt_password = mqtt_password;

    /*----------------------------------------------------------------------------------------------------------------*/

    auto mqtt_callback = [node](STR_t topic, byte *buff, unsigned int size)
    {
        nyx_str_t message = {(str_t) buff, (size_t) size};

        node->mqtt_handler(node, NYX_EVENT_MSG, nyx_str_s(topic), message);
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    if(node->tcp_url != NULL)
    {
        IPAddress ip;
        int port;

        if(parse_host_port(node->tcp_url, ip, port, 7624))
        {
            stack->tcp_server = WiFiServer(ip, port);

            stack->tcp_server.begin();
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(node->mqtt_url != NULL)
    {
        IPAddress ip;
        int port;

        if(parse_host_port(node->mqtt_url, ip, port, 1883))
        {
            stack->mqtt_client.setCallback(
                mqtt_callback
            );

            stack->mqtt_client.setServer(
                ip, port
            );
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_node_stack_finalize(nyx_node_t *node)
{
    /*----------------------------------------------------------------------------------------------------------------*/
    /* FINALIZE TCP                                                                                                   */
    /*----------------------------------------------------------------------------------------------------------------*/

    auto clients = node->stack->clients;

    for(int i = 0; i < MAX_TCP_CLIENTS; i++)
    {
        clients[i].tcp_client.stop();
    }

    node->stack->tcp_server.stop();

    /*----------------------------------------------------------------------------------------------------------------*/
    /* FINALIZE MQTT                                                                                                  */
    /*----------------------------------------------------------------------------------------------------------------*/

    node->stack->mqtt_client.disconnect();

    /*----------------------------------------------------------------------------------------------------------------*/
    /* FINALIZE STACK                                                                                                 */
    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_memory_free(node->stack);

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_stack_poll(nyx_node_t *node, int timeout_ms)
{
    auto stack = node->stack;

    auto clients = stack->clients;

    /*----------------------------------------------------------------------------------------------------------------*/
    /* TCP                                                                                                            */
    /*----------------------------------------------------------------------------------------------------------------*/

    if(node->tcp_url != NULL)
    {
        /*------------------------------------------------------------------------------------------------------------*/
        /* REGISTER CLIENTS                                                                                           */
        /*------------------------------------------------------------------------------------------------------------*/

        WiFiClient new_client = stack->tcp_server.accept();

        if(new_client && new_client.connected())
        {
            for(int i = 0; i < MAX_TCP_CLIENTS; ++i)
            {
                auto &client = clients[i];

                if(!client.tcp_client || !client.tcp_client.connected())
                {
                    client.tcp_client = new_client;

                    client.recv_head = 0;
                    client.recv_tail = 0;

                    goto __ok;
                }
            }

            new_client.stop();
        }

        /*------------------------------------------------------------------------------------------------------------*/
        /* RECIEVE DATA                                                                                               */
        /*------------------------------------------------------------------------------------------------------------*/
__ok:
        for(int i = 0; i < MAX_TCP_CLIENTS; i++)
        {
            auto &client = clients[i];

            if(client.tcp_client && client.tcp_client.connected())
            {
                /*----------------------------------------------------------------------------------------------------*/

                while(client.tcp_client.available() > 0)
                {
                    int c = client.tcp_client.read();

                    if(c >= 0)
                    {
                        size_t next = (client.recv_head + 1) % RECV_BUFF_SIZE;

                        if(client.recv_tail != next)
                        {
                            client.recv_buff[client.recv_head] = (char) c;

                            client.recv_head = next;
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                /*----------------------------------------------------------------------------------------------------*/

                size_t initial_available = (client.recv_head + RECV_BUFF_SIZE - client.recv_tail) % RECV_BUFF_SIZE;

                /*----------------------------------------------------------------------------------------------------*/

                if(initial_available > 0)
                {
                    size_t pos = client.recv_tail;
                    size_t consumed = 0x0000000000000;
                    size_t available = initial_available;

                    while(available > 0)
                    {
                        size_t len = (client.recv_head > pos)
                            ? client.recv_head - pos
                            : RECV_BUFF_SIZE - pos
                        ;

                        if(len > available)
                        {
                            len = available;
                        }

                        size_t c = node->tcp_handler(node, NYX_EVENT_MSG, len, client.recv_buff + pos);

                        consumed += c;
                        if(c < len) { break; } pos = (pos + c) % RECV_BUFF_SIZE;
                        available -= c;
                    }

                    client.recv_tail = (consumed <= initial_available)
                        ? (client.recv_tail + consumed) % RECV_BUFF_SIZE
                        : (client.recv_head)
                    ;
                }

                /*----------------------------------------------------------------------------------------------------*/
            }
        }

        /*------------------------------------------------------------------------------------------------------------*/
    }

    /*----------------------------------------------------------------------------------------------------------------*/
    /* MQTT                                                                                                           */
    /*----------------------------------------------------------------------------------------------------------------*/

    if(node->mqtt_url != NULL)
    {
        /*------------------------------------------------------------------------------------------------------------*/

        if(!stack->mqtt_client.connected())
        {
            if(stack->mqtt_client.connect(node->node_id.buf, stack->mqtt_username, stack->mqtt_password))
            {
                node->mqtt_handler(node, NYX_EVENT_OPEN, node->node_id, node->node_id);
            }
            else
            {
                delay(timeout_ms);

                return;
            }
        }

        /*------------------------------------------------------------------------------------------------------------*/

        stack->mqtt_client.loop();

        /*------------------------------------------------------------------------------------------------------------*/
    }

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/
#endif
/*--------------------------------------------------------------------------------------------------------------------*/
