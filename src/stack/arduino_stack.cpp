/*--------------------------------------------------------------------------------------------------------------------*/
#if defined(ARDUINO)
/*--------------------------------------------------------------------------------------------------------------------*/

#include <string.h>

#ifndef ESP8266
#  include <WiFi.h>
#else
#  include <ESP8266WiFi.h>
#endif

#include <Arduino.h>
#include <PubSubClient.h>

#include "../nyx_node_internal.h"

/*--------------------------------------------------------------------------------------------------------------------*/

#define RECV_BUFF_SIZE 512

/*--------------------------------------------------------------------------------------------------------------------*/

struct nyx_stack_s
{
    /*----------------------------------------------------------------------------------------------------------------*/

    __NULLABLE__ WiFiServer *tcp_server;

    char recv_buff[RECV_BUFF_SIZE];

    size_t recv_head = 0;
    size_t recv_tail = 0;

    /*----------------------------------------------------------------------------------------------------------------*/

    __NULLABLE__ PubSubClient *mqtt_client;

    __NULLABLE__ STR_t mqtt_username;
    __NULLABLE__ STR_t mqtt_password;

    /*----------------------------------------------------------------------------------------------------------------*/
};

/*--------------------------------------------------------------------------------------------------------------------*/
/* UTILITY                                                                                                            */
/*--------------------------------------------------------------------------------------------------------------------*/

static size_t recv_size(nyx_stack_t* stack)
{
    return (stack->recv_head + RECV_BUFF_SIZE - stack->recv_tail) % RECV_BUFF_SIZE;
}

/*--------------------------------------------------------------------------------------------------------------------*/
/* LOGGER                                                                                                             */
/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_log_prefix(nyx_log_level_t level, STR_t file, STR_t func, int line)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    STR_t p;

    p = strrchr(file, '/');

    if(p != NULL)
    {
        file = p + 1;
    }
    else
    {
        p = strrchr(file, '\\');

        if(p != NULL)
        {
            file = p + 1;
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    Serial.printf("%s - %s: %d %s() - ", nyx_log_level_to_str(level), file, line, func);

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_log(const char *fmt, ...)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    va_list ap;
    va_start(ap, fmt);

    va_end(ap);

    /*----------------------------------------------------------------------------------------------------------------*/

    Serial.print('\r');
    Serial.print('\n');

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/
/* TCP & MQTT                                                                                                         */
/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_tcp_pub(nyx_node_t *node, STR_t message)
{
    if(node->stack->tcp_server != NULL)
    {
        node->stack->tcp_server->write(message);
    }
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_mqtt_sub(nyx_node_t *node, nyx_str_t topic, int qos)
{
    if(node->stack->mqtt_client != NULL)
    {
        node->stack->mqtt_client->subscribe(topic.buf, qos);
    }
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_mqtt_pub(nyx_node_t *node, nyx_str_t topic, nyx_str_t message, int qos, bool retain)
{
    if(node->stack->mqtt_client != NULL)
    {
        node->stack->mqtt_client->publish(topic.buf, (const uint8_t *) message.buf, (unsigned int) message.len, retain);
    }
}

/*--------------------------------------------------------------------------------------------------------------------*/
/* STACK                                                                                                              */
/*--------------------------------------------------------------------------------------------------------------------*/

static bool parse_host_port(const std::string &url, IPAddress &ip, int &port, int default_port)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    std::string host;

    size_t colon = url.find(':');

    if(colon == std::string::npos)
    {
        host = url;
        port = default_port;
    }
    else
    {
        host = url.substr(0, colon);
        port = std::stoi(url.substr(colon + 1));
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(ip.fromString(host.c_str()))
    {
        return true;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(WiFi.hostByName(host.c_str(), ip) == 1)
    {
        return true;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    return false;
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_node_stack_initialize(
    nyx_node_t *node,
    __NULLABLE__ STR_t mqtt_username,
    __NULLABLE__ STR_t mqtt_password,
    int retry_ms
) {
    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_stack_t *stack = node->stack = (nyx_stack_t *) nyx_memory_alloc(sizeof(nyx_stack_t));

    memset(stack, 0, sizeof(nyx_stack_t));

    /*----------------------------------------------------------------------------------------------------------------*/

    stack->mqtt_username = mqtt_username;
    stack->mqtt_password = mqtt_password;

    /*----------------------------------------------------------------------------------------------------------------*/

    if(node->tcp_url != NULL)
    {
        IPAddress ip;
        int port;

        if(parse_host_port(node->tcp_url, ip, port, 7624))
        {
            stack->tcp_server = new WiFiServer(ip, port);

            stack->tcp_server->begin();
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(node->mqtt_url != NULL)
    {
        IPAddress ip;
        int port;

        if(parse_host_port(node->mqtt_url, ip, port, 1883))
        {
            stack->mqtt_client = new PubSubClient();

            stack->mqtt_client->setServer(
                ip, port
            );

            stack->mqtt_client->setCallback(
                [node](STR_t topic, byte *buff, unsigned int size)
                {
                    nyx_str_t message = {(str_t) buff, (size_t) size};

                    node->mqtt_handler(node, NYX_EVENT_MSG, nyx_str_s(topic), message);
                }
            );
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_node_stack_finalize(nyx_node_t *node)
{
    /*----------------------------------------------------------------------------------------------------------------*/
    /* TCP                                                                                                            */
    /*----------------------------------------------------------------------------------------------------------------*/

    if(node->stack->tcp_server != NULL)
    {
        node->stack->tcp_server->/**/close/**/();

        delete node->stack->tcp_server;
    }

    /*----------------------------------------------------------------------------------------------------------------*/
    /* MQTT                                                                                                           */
    /*----------------------------------------------------------------------------------------------------------------*/

    if(node->stack->mqtt_client != NULL)
    {
        node->stack->mqtt_client->disconnect();

        delete node->stack->mqtt_client;
    }

    /*----------------------------------------------------------------------------------------------------------------*/
    /* STACK                                                                                                          */
    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_memory_free(node->stack);

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_stack_poll(nyx_node_t *node, int timeout_ms)
{
    nyx_stack_t *stack = node->stack;

    /*----------------------------------------------------------------------------------------------------------------*/
    /* TCP                                                                                                            */
    /*----------------------------------------------------------------------------------------------------------------*/

    if(stack->tcp_server != NULL)
    {
        WiFiClient client = stack->tcp_server->available();

        if(client && client.connected())
        {
            /*--------------------------------------------------------------------------------------------------------*/

            while(client.available() > 0)
            {
                int c = client.read();

                if(c >= 0)
                {
                    size_t next = (stack->recv_head + 1) % RECV_BUFF_SIZE;

                    if(stack->recv_tail != next)
                    {
                        stack->recv_buff[stack->recv_head] = (char) c;

                        stack->recv_head = next;
                    }
                }
                else
                {
                    break;
                }
            }

            /*--------------------------------------------------------------------------------------------------------*/

            size_t available = recv_size(stack);

            if(available > 0)
            {
                size_t consumed = 0;
                size_t pos = stack->recv_tail;

                while(available > 0)
                {
                    size_t len = (stack->recv_head > pos)
                        ? stack->recv_head - pos
                        : RECV_BUFF_SIZE - pos
                    ;

                    if(len > available)
                    {
                        len = available;
                    }

                    size_t c = node->tcp_handler(node, NYX_EVENT_MSG, len, stack->recv_buff + pos);

                    consumed += c;
                    if (c < len) break; pos = (pos + c) % RECV_BUFF_SIZE;
                    available -= c;
                }

                stack->recv_tail = (consumed <= recv_size(stack))
                    ? (stack->recv_tail + consumed) % RECV_BUFF_SIZE
                    : stack->recv_head
                ;
            }

            /*--------------------------------------------------------------------------------------------------------*/
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/
    /* MQTT                                                                                                           */
    /*----------------------------------------------------------------------------------------------------------------*/

    if(stack->mqtt_client)
    {
        /*------------------------------------------------------------------------------------------------------------*/

        if(!stack->mqtt_client->connected())
        {
            if (stack->mqtt_client->connect(node->node_id.buf, stack->mqtt_username, stack->mqtt_password))
            {
                node->mqtt_handler(node, NYX_EVENT_OPEN, node->node_id, node->node_id);
            }
            else
            {
                delay(timeout_ms);

                return;
            }
        }

        /*------------------------------------------------------------------------------------------------------------*/

        stack->mqtt_client->loop();

        /*------------------------------------------------------------------------------------------------------------*/
    }

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/
#endif
/*--------------------------------------------------------------------------------------------------------------------*/
