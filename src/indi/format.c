/* NyxNode
 * Author: Jérôme ODIER <jerome.odier@lpsc.in2p3.fr>
 * SPDX-License-Identifier: GPL-2.0-only (Mongoose backend) or GPL-3.0+
 */

/*--------------------------------------------------------------------------------------------------------------------*/

#include <math.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../nyx_node_internal.h"

/*--------------------------------------------------------------------------------------------------------------------*/
/* UTILITIES                                                                                                          */
/*--------------------------------------------------------------------------------------------------------------------*/

static bool _parse_format(char *result_conv, int *result_lcnt, int *result_w, int *result_f, STR_t s)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    STR_t p = strchr(s, '%');
    if(p == NULL) { return false; }

    p++;

    STR_t q = strchr(p, '%');
    if(q != NULL) { return false; }

    /*----------------------------------------------------------------------------------------------------------------*/

    while(*p == '+' || *p == '-' || *p == ' ' || *p == '#' || *p == '0') { p++; }

    /*----------------------------------------------------------------------------------------------------------------*/

    int w = 0;
    int f = 0;

    bool have_w = false;
    bool have_f = false;

    while(isdigit((unsigned char) *p)) { w = (w * 10) + (int) (*p++ - '0'); have_w = true; }

    if(*p == '.')
    {
        p++;

        while(isdigit((unsigned char) *p)) { f = (f * 10) + (int) (*p++ - '0'); have_f = true; }
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(*p == 'm')
    {
        /*------------------------------------------------------------------------------------------------------------*/

        p++;

        /*------------------------------------------------------------------------------------------------------------*/

        if(*p != '\0') { return false; }

        if(!(have_w && have_f)) { return false; }

        if(f != 3 && f != 5 && f != 6 && f != 8 && f != 9) { return false; }

        /*------------------------------------------------------------------------------------------------------------*/

        if(result_conv != NULL) { *result_conv = 'm'; }
        if(result_lcnt != NULL) { *result_lcnt =  0 ; }
        if(result_w    != NULL) { *result_w    =  w ; }
        if(result_f    != NULL) { *result_f    =  f ; }

        /*------------------------------------------------------------------------------------------------------------*/

        return true;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    int lcnt = 0;

    /**/ if(*p == 'l')
    {
        lcnt = 1; p++;
        if(*p == 'l') { lcnt = 2; p++; }
    }
    else if(*p == 'h' || *p == 'j' || *p == 'z' || *p == 't' || *p == 'L')
    {
        return false;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(*p == '\0') { return false; }

    char conv = *p++; if(conv == 'n') { return false; }

    if(*p != '\0') { return false; }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(result_conv != NULL) { *result_conv = conv; }
    if(result_lcnt != NULL) { *result_lcnt = lcnt; }
    if(result_w    != NULL) { *result_w    = 0x00; }
    if(result_f    != NULL) { *result_f    = 0x00; }

    /*----------------------------------------------------------------------------------------------------------------*/

    return true;
}

/*--------------------------------------------------------------------------------------------------------------------*/

static double sextod(STR_t p)
{
    double deg;
    double min;
    double sec;

    /*----------------------------------------------------------------------------------------------------------------*/

    while(*p != '\0' && isspace((unsigned char) *p)) { p++; }

    /*----------------------------------------------------------------------------------------------------------------*/

    double sign = 1;

    for(;;)
    {
        /**/ if(*p == '-') { sign *= -1; p++; }
        else if(*p == '+') { sign *= +1; p++; }
        else {
            break;
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    str_t end1 = NULL;
    deg = (double) strtol(p, &end1, 10);

    if(p == end1) {
        return NAN;
    }
    else {
        p = end1;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(*p != ':') { return NAN; } p++;

    /*----------------------------------------------------------------------------------------------------------------*/

    STR_t colon = strchr(p, ':');

    if(colon != NULL)
    {
        /*------------------------------------------------------------------------------------------------------------*/

        str_t end2 = NULL;
        min = (double) strtol(p, &end2, 10);

        if(p == end2) {
            return NAN;
        }
        else {
            p = end2;
        }

        /*------------------------------------------------------------------------------------------------------------*/

        if(p != colon) { return NAN; } p++;

        /*------------------------------------------------------------------------------------------------------------*/

        str_t end3 = NULL;
        sec = (double) strtod(p, &end3);

        if(p == end3) {
            return NAN;
        }
        else {
            p = end3;
        }

        /*------------------------------------------------------------------------------------------------------------*/
    }
    else
    {
        /*------------------------------------------------------------------------------------------------------------*/

        str_t end4 = NULL;
        min = (double) strtod(p, &end4);

        if(p == end4) {
            return NAN;
        }
        else {
            p = end4;
        }

        /*------------------------------------------------------------------------------------------------------------*/

        sec = 0.0;

        /*------------------------------------------------------------------------------------------------------------*/
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    while(*p != '\0' && isspace((unsigned char) *p)) { p++; }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(*p != '\0') { return NAN; }

    if(!(min >= 0.0 && min < 60.0)) { return NAN; }

    if(!(sec >= 0.0 && sec < 60.0)) { return NAN; }

    /*----------------------------------------------------------------------------------------------------------------*/

    return sign * (deg + (min / 60.0) + (sec / 3600.0));

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

static int snprintm(str_t dst_str, size_t dst_len, int w, int f, double value)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    STR_t sign_str = signbit(value) ? "-"
                                    : ""
    ;

    value = fabs(value);

    /*----------------------------------------------------------------------------------------------------------------*/

    int deg_i = (int) floor(value);

    double frac_d = value - (double) deg_i;

    /*----------------------------------------------------------------------------------------------------------------*/

    char core[64];

    switch(f)
    {
        case 3: /* :mm */
        {
            long m1 = lround(frac_d * 60.0);
            int  mm = (int) m1;

            if(mm >= 60) { mm = 0; deg_i++; }

            snprintf(core, sizeof(core), "%s%d:%02d", sign_str, deg_i, mm);
        }
            break;

        case 5: /* :mm.m */
        {
            long m10   = lround(frac_d * 600.0);
            int  mm    = (int) (m10 / 10);
            int  mm_t1 = (int) (m10 % 10);

            if(mm >= 60) { mm = 0; deg_i++; }

            snprintf(core, sizeof(core), "%s%d:%02d.%01d", sign_str, deg_i, mm, mm_t1);
        }
            break;

        case 6: /* :mm:ss */
        {
            long s1 = lround(frac_d * 3600.0);
            int  mm = (int) (s1 / 60);
            int  ss = (int) (s1 % 60);

            if(mm >= 60) { mm = 0; deg_i++; }

            snprintf(core, sizeof(core), "%s%d:%02d:%02d", sign_str, deg_i, mm, ss);
        }
            break;

        case 8: /* :mm:ss.s */
        {
            long s10   = lround(frac_d * 36000.0);
            int  mm    = (int) (s10 / 600);
            int  ss    = (int) ((s10 % 600) / 10);
            int  ss_t1 = (int) (s10 % 10);

            if(mm >= 60) { mm = 0; deg_i++; }

            snprintf(core, sizeof(core), "%s%d:%02d:%02d.%01d", sign_str, deg_i, mm, ss, ss_t1);
        }
            break;

        case 9: default: /* :mm:ss.ss */
        {
            long s100  = lround(frac_d * 360000.0);
            int  mm    = (int) (s100 / 6000);
            int  ss    = (int) ((s100 % 6000) / 100);
            int  ss_t2 = (int) (s100 % 100);

            if(mm >= 60) { mm = 0; deg_i++; }

            snprintf(core, sizeof(core), "%s%d:%02d:%02d.%02d", sign_str, deg_i, mm, ss, ss_t2);
        }
            break;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if(w > 0) {
        return snprintf(dst_str, dst_len, "%*s", w, core);
    } else {
        return snprintf(dst_str, dst_len, "%s", core);
    }

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/
/* FORMAT DOUBLE                                                                                                      */
/*--------------------------------------------------------------------------------------------------------------------*/

nyx_string_t *nyx_format_double_to_string(STR_t format, double value)
{
    char conv;
    int lcnt, w, f;

    char buffer[64];

    if(_parse_format(&conv, &lcnt, &w, &f, format))
    {
        /**/ if(lcnt == 1)
        {
            if(((conv == 'd' /*----------------------------------------------------------------------*/) && snprintf(buffer, sizeof(buffer), format, (signed long) value) >= 0)
               ||
               ((conv == 'u' || conv == 'o' || conv == 'x' || conv == 'X' /*-------------------------*/) && snprintf(buffer, sizeof(buffer), format, (unsigned long) value) >= 0)
               ||
               ((conv == 'f' || conv == 'F' || conv == 'e' || conv == 'E' || conv == 'g' || conv == 'G') && snprintf(buffer, sizeof(buffer), format, (double) value) >= 0)
               ||
               ((conv == 'm' /*----------------------------------------------------------------------*/) && snprintm(buffer, sizeof(buffer), w, f, value) >= 0)
            ) {
                return nyx_string_from_dup(buffer);
            }
        }
        else if(lcnt == 0)
        {
            if(((conv == 'd' /*----------------------------------------------------------------------*/) && snprintf(buffer, sizeof(buffer), format, (signed int) value) >= 0)
               ||
               ((conv == 'u' || conv == 'o' || conv == 'x' || conv == 'X' /*-------------------------*/) && snprintf(buffer, sizeof(buffer), format, (unsigned int) value) >= 0)
               ||
               ((conv == 'f' || conv == 'F' || conv == 'e' || conv == 'E' || conv == 'g' || conv == 'G') && snprintf(buffer, sizeof(buffer), format, (double) value) >= 0)
               ||
               ((conv == 'm' /*----------------------------------------------------------------------*/) && snprintm(buffer, sizeof(buffer), w, f, value) >= 0)
            ) {
                return nyx_string_from_dup(buffer);
            }
        }
    }

    NYX_LOG_ERROR("This function is not compatible with the format `%s`", format);

    return nyx_string_from_dup("0");
}

/*--------------------------------------------------------------------------------------------------------------------*/

double nyx_format_string_to_double(STR_t format, nyx_string_t *value)
{
    char conv;

    if(_parse_format(&conv, NULL, NULL, NULL, format))
    {
        if(conv == 'd' || conv == 'u' /*-------------------------------------------------------*/) {
            return (double) strtol(value->value, NULL, 10);
        }
        if(conv == 'o' /*----------------------------------------------------------------------*/) {
            return (double) strtol(value->value, NULL, 8);
        }
        if(conv == 'x' || conv == 'X' /*-------------------------------------------------------*/) {
            return (double) strtol(value->value, NULL, 16);
        }
        if(conv == 'f' || conv == 'F' || conv == 'e' || conv == 'E' || conv == 'g' || conv == 'G') {
            return (double) strtod(value->value, NULL);
        }
        if(conv == 'm' /*----------------------------------------------------------------------*/) {
            return (double) sextod(value->value);
        }
    }

    NYX_LOG_ERROR("This function is not compatible with the format `%s`", format);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------*/
